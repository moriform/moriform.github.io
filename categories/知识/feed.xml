<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>知识 on 森月台</title>
        <link>https://moriform.github.io/categories/%E7%9F%A5%E8%AF%86/</link>
        <description>Recent content in 知识 on 森月台</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>暄穗</copyright>
        <lastBuildDate>Sun, 22 Feb 2026 21:38:26 +0000</lastBuildDate><atom:link href="https://moriform.github.io/categories/%E7%9F%A5%E8%AF%86/feed.xml" rel="self" type="application/rss+xml" /><item>
        <title>在Reaper中实现响度补偿的一种方法</title>
        <link>https://moriform.github.io/2026/02/22/magcgaincompensation/</link>
        <pubDate>Sun, 22 Feb 2026 21:38:26 +0000</pubDate>
        
        <guid>https://moriform.github.io/2026/02/22/magcgaincompensation/</guid>
        <description>&lt;h2 id=&#34;响度补偿的必要性&#34;&gt;响度补偿的必要性
&lt;/h2&gt;&lt;p&gt;音频处理制作的过程中，我们免不了使用各种插件对音频进行加工。而在加工的途中，响度会成为干扰制作角度审美的一大因素，比如通过饱和激励等处理的鼓组会因为响度大于原来的响度，只要不极端不管如何调节参数听上去都会让人更能接受。这样响度越大越好听的审美心理也直接影响到响度大战。&lt;/p&gt;
&lt;p&gt;但是在音频制作的过程中，制作人不应该因为给音频增加压缩调节EQ增加失真的时候响度发生变化而影响自己的审美。一些插件给出了响度补偿(gain compensation)的方案，让输出的音频响度和输入的音频响度保持一致，避免响度差异带来误判。&lt;/p&gt;
&lt;p&gt;本文使用Melda Production的免费插件MAGC演示在Reaper中实现响度补偿的方案，这套方案可用于大部分音频处理插件在处理过程中保持响度不变。&lt;/p&gt;
&lt;h2 id=&#34;magc&#34;&gt;MAGC
&lt;/h2&gt;&lt;p&gt;MAGC(读作magic)是MeldaProduction(后文称作红塔山)推出的免费插件，处于他们家免费插件包按字母排序的第一个。如果不看说明书就直接把它拖进音轨发现毫无用处又因为红塔山的尿性忍着难看的UI和完全没有新手引导胡乱操作一通就会十分影响学习积极性。&lt;/p&gt;
&lt;p&gt;效果是将主音频信号的动态响度跟踪为侧链信号的动态响度，保持音轨音频和侧链音频响度逼近。&lt;/p&gt;
&lt;p&gt;举一个例子，在电音中时常会听见Lead具有和鼓点一样的呼吸感，每当鼓点响的时候鼓点作为侧链增加就会Lead的响度（注意不是侧链压缩，侧链压缩是鼓点响的时候反而让主音频响度减小，主音频和侧链信号呈负相关）。&lt;/p&gt;
&lt;p&gt;所以我们可以很容易想到使用这个插件实现响度补偿的逻辑：经过效果器一系列处理的音频作为主音轨输入到MAGC中，完全没有任何效果器处理的原声音频作为侧链输入到MAGC的侧链中，时刻将主音轨和侧链的响度进行对比。如果主音轨响度不同于侧链，MAGC就降低或升高主音轨的响度到向侧链的响度逼近。&lt;/p&gt;
&lt;h2 id=&#34;在reaper中的操作&#34;&gt;在Reaper中的操作
&lt;/h2&gt;&lt;p&gt;这个插件的使用会涉及到Reaper音频轨道中的路由设置。为了不每一次使用MAGC的时候都要重新设置路由，我将演示使用Reaper中FX轨道的“容器”来创建子FX轨，将插件和路由的设置放在容器中，然后把容器作为FX chain预设保存起来，这样每一次调用响度补偿方法的时候就可以直接使用这个FX chain把其他效果器拖入正确位置就可以。&lt;/p&gt;
&lt;h3 id=&#34;响度补偿的路由逻辑&#34;&gt;响度补偿的路由逻辑
&lt;/h3&gt;&lt;p&gt;响度补偿的路由和操作逻辑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/gaincompensation.webp&#34;
	width=&#34;750&#34;
	height=&#34;196&#34;
	srcset=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/gaincompensation_hu_cc9c6081798fb70a.webp 480w, https://moriform.github.io/2026/02/22/magcgaincompensation/gaincompensation_hu_12882030fb96ae8c.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;382&#34;
		data-flex-basis=&#34;918px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;即整个效果需要一个Gain Compensation容器，容器设置为4个输入2个输出。输入1和输入2（原声左声道和右声道）输入到Effectors容器，用于音频处理（2输入2输出）。Effectors容器的输出作为主音频输入MAGC，Gain Compensation容器的输入3和输入4（也是原声左声道和右声道）作为侧链输入到MAGC的侧链通道。MAGC经过处理之后输出一个经过处理且响度和原声相同的音频作为整个容器的输出。&lt;/p&gt;
&lt;h3 id=&#34;实际操作&#34;&gt;实际操作
&lt;/h3&gt;&lt;p&gt;在FX track中右键Add container就可以添加容器，如图我在音轨的FX track上添加了Gain Compensation Stereo容器，在Gain Compensation Stereo容器中添加了Effectors容器。（在Gain Compensation Stereo添加Gain效果器用于调整原声的响度，而Effectors中的Gain只用于测试，测试方法后文会提到。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/reaper_y9FIXtBtm5.webp&#34;
	width=&#34;1239&#34;
	height=&#34;1013&#34;
	srcset=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/reaper_y9FIXtBtm5_hu_7ea71b1347b35104.webp 480w, https://moriform.github.io/2026/02/22/magcgaincompensation/reaper_y9FIXtBtm5_hu_bdb6acbb4f5b5dc9.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;293px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;设置Gain Compensation Stereo容器的路由如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/AGMLffQG0m.webp&#34;
	width=&#34;502&#34;
	height=&#34;312&#34;
	srcset=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/AGMLffQG0m_hu_7916699ce3a9c280.webp 480w, https://moriform.github.io/2026/02/22/magcgaincompensation/AGMLffQG0m_hu_433d3d804663ee28.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;386px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Track Channel 1/2是原声，输入到input 1/2作为处理声音，输入到3/4作为参考侧链。Output 1/2是最后效果器处理且响度补偿后的音频输出。&lt;/p&gt;
&lt;p&gt;设置Effectors容器的路由如下：
&lt;img src=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/rAzUZayTvY.webp&#34;
	width=&#34;502&#34;
	height=&#34;352&#34;
	srcset=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/rAzUZayTvY_hu_4cd2ca7fc6c25ce1.webp 480w, https://moriform.github.io/2026/02/22/magcgaincompensation/rAzUZayTvY_hu_d63d69cdc4256d79.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;342px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;只取主容器的1/2输入到该容器中，容器内部就是正常的双声道音轨的插件摆放。&lt;/p&gt;
&lt;p&gt;设置MAGC的路由如下：
&lt;img src=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/F87nbTawlw.webp&#34;
	width=&#34;610&#34;
	height=&#34;314&#34;
	srcset=&#34;https://moriform.github.io/2026/02/22/magcgaincompensation/F87nbTawlw_hu_f400047a525e4e2a.webp 480w, https://moriform.github.io/2026/02/22/magcgaincompensation/F87nbTawlw_hu_d5b08933f65fdb7.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;194&#34;
		data-flex-basis=&#34;466px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;注意MAGC摆放在主容器内，且在Effector容器的下面，所以对于MAGC来说Container Channel 1/2就是Effector输出的效果器处理音频，Container Channel 3/4就是一直没有动过的原声（和逻辑图的Channel一致）。MAGC处理的声音作为成品声音输出到Container Channel 1/2，整个过程结束。&lt;/p&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证
&lt;/h3&gt;&lt;p&gt;可以通过在Effectors中放一个Gain来验证（因为最直观）。
在MAGC中设置的range参数是指MAGC可以为响度补偿调整的最大响度。比如range是20dB，那么如果我在Gain插件里面调整Gain范围在-20dB~+20dB之间的时候，听见的声音基本是不会变化的，如+10dB的时候，可以看见插件图中G往零下压了10分贝。如果Gain插件+30dB,MAGC最多补偿设置的20dB，剩下的10dB超出了range范围就无法处理了，可以听到声音变大。&lt;/p&gt;
&lt;p&gt;或者，在Effectors中随意放一些插件把音频变得很随意，然后在MAGC中选择Side-chain listen，此时听见的是没有进行处理的原声，也说明系统搭建成功了。&lt;/p&gt;
&lt;h3 id=&#34;打包&#34;&gt;打包
&lt;/h3&gt;&lt;p&gt;由于每一次使用MAGC做响度补偿都会调整路由十分繁琐，所以本文介绍的方法给整个插件和路由都封装了。右键Gain Compensation Stereo，移动到FX chains,选择Save FX as chain&amp;hellip;，这样以后都可以一键响度补偿了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于AviUtl的自定义UI</title>
        <link>https://moriform.github.io/2026/01/10/avitulinstallzoku/</link>
        <pubDate>Sat, 10 Jan 2026 21:38:26 +0000</pubDate>
        
        <guid>https://moriform.github.io/2026/01/10/avitulinstallzoku/</guid>
        <description>&lt;h2 id=&#34;前置准备&#34;&gt;前置准备
&lt;/h2&gt;&lt;p&gt;前置准备参考前三篇关于AviUtl的文章。&lt;/p&gt;
&lt;h2 id=&#34;客制化&#34;&gt;客制化
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ePi5131/patch.aul&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Patch&lt;/a&gt;插件的发布直接拉高了AUL的性能，以此为基础&lt;a class=&#34;link&#34; href=&#34;https://github.com/hebiiro&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hebiiro (蛇色(へびいろ))&lt;/a&gt;大佬发布了一系列的插件能够对AUL的UI进行自定义，其中瞩目的是&lt;a class=&#34;link&#34; href=&#34;https://github.com/hebiiro/AviUtl-Plugin-SplitWindow&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SplitWindow&lt;/a&gt;，&lt;a class=&#34;link&#34; href=&#34;https://github.com/hebiiro/AviUtl-Plugin-DarkenWindow&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;黒窓&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;https://github.com/hebiiro/AviUtl-Plugin-ObjectExplorer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt; オブジェクトエクスプローラ&lt;/a&gt;。通过这三个插件可以将整个AUL的UI布置成一个标准视频剪辑软件的界面，也弥补了AUL多年没有媒体池的缺陷。&lt;/p&gt;
&lt;p&gt;需要注意的是有以下插件冲突和替代情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SplitWindow和psdtool kit在之前测试的时候同时安装psdtool kit无法打开。&lt;/li&gt;
&lt;li&gt;オブジェクトエクスプローラ是插件篇中提到的&lt;a class=&#34;link&#34; href=&#34;https://aoytsk.blog.jp/aviutl/1151849.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文件管理器&lt;/a&gt;的上位替代。&lt;/li&gt;
&lt;li&gt;SplitWindow和&lt;a class=&#34;link&#34; href=&#34;https://github.com/amate/PropertyWindowFixerPlugin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PropertyWindowFixerPlugin&lt;/a&gt;同时使用会导致报错，如果想要窗口一体化的话，一体化窗口就已经包括了WindowFixerPlugin的效果。可以在[表示]中选择取消勾选画面size固定化plugin来避免在文件夹里删除插件的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装过程如视频所示，包括基本插件的安装，以及一些进阶的自定义操作。&lt;/p&gt;
&lt;iframe id=&#34;spkj&#34; src=&#34;https://www.acfun.cn/player/ac43509163&#34; width=&#34;100%&#34; frameborder=&#34;no&#34; scrolling=&#34;no&#34; allowfullscreen=&#34;allowfullscreen&#34;&gt;&lt;span data-mce-type=&#34;bookmark&#34; style=&#34;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&#34; class=&#34;mce_SELRES_start&#34;&gt;&lt;/span&gt; &lt;span data-mce-type=&#34;bookmark&#34; style=&#34;display: inline-block; width: 0px; overflow: hidden; line-height: 0;&#34; class=&#34;mce_SELRES_start&#34;&gt;&lt;/span&gt; &lt;/iframe&gt; &lt;script type=&#34;text/javascript&#34;&gt; document.getElementById(&#34;spkj&#34;).style.height=document.getElementById(&#34;spkj&#34;).scrollWidth*0.76+&#34;px&#34;; &lt;/script&gt;
&lt;h2 id=&#34;后话&#34;&gt;后话
&lt;/h2&gt;&lt;p&gt;2021年10月6日我发布了一篇《关于Aviutl的基本安装说明》。当时想法十分天真，打算做一系列插件和脚本的使用教程，结果只更新了三篇文章就去忙其他事情了。那三篇已经把当时的AviUtl该讲的配置和基本使用方法介绍得差不多，读完了那几篇就可以自己配置软件开始制作视频并深入研究这个软件圈子了。&lt;/p&gt;
&lt;p&gt;在那之后AUL发生了一些大事，其一是ePi5131大佬发布并持续更新patch.aul插件极大提高了这个快30岁的软件的性能，在这个插件的基础上社区内又持续更新了一堆脚本和插件。其二是神一样的KEN在半年前发布了AUL2，重新构建了这个软件，最直接的感受是页面不会像1代一样碎一屏幕，更加符合当代视频剪辑软件界面；以及AUL2是惊人的极为先进的64位软件，性能大幅度提高，并且不会产生内存占满的情况了。&lt;/p&gt;
&lt;p&gt;目前的情况是：Aul2持续发布更新，半年发布了27个beta版本。由于AUL和AUL2属于完全不一样的软件，其他比较出名的插件和脚本制作者在更新AUL1的插件和脚本的时候也在同步开发AUL2的适配插件。大方向一定是最后AUL2大部分代替AUL1，但是现在仍然处于过渡阶段。&lt;/p&gt;
&lt;p&gt;我个人预计在很长时间里都不会去使用AUL2，因为目前更新速度过快没有稳定下来也不如AUL1用得熟练，而且我个人使用这个软件的频率现在也不多了，目前更多时候拿剪映剪剪再加上字幕就够了。&lt;/p&gt;
&lt;p&gt;本来我打算写点有的没的作为前三篇的补充，将那之后的一些瞩目的更新插件简要过一遍。以便总结结束之后去尝试新的AUL2，但是实际上细碎的东西太多了真要细讲不是几篇就能说完的，所以选了个能够增加编辑视频幸福感的方面简要介绍一下。剩下的相信靠读者强大的搜索能力和浏览器强大的翻译能力以及AI也能找到自己想要的信息。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>摇曳露营中的实时摄像头</title>
        <link>https://moriform.github.io/2026/01/09/yurucamera/</link>
        <pubDate>Fri, 09 Jan 2026 15:01:47 +0000</pubDate>
        
        <guid>https://moriform.github.io/2026/01/09/yurucamera/</guid>
        <description>&lt;p&gt;摇曳露营第一季中芝麻凛给抚子发送的实时摄像机链接是LCV社为詶访地区设立的道路状况的28个监控中的&lt;a class=&#34;link&#34; href=&#34;https://live.lcv.ne.jp/cgi-bin/road/movie.php?camera_id=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;霧ヶ峰映像&lt;/a&gt;)，LCV的这套系统一般人使用需要成为LCV-Net会员，但是唯独霧ヶ峰的监控是不需要登录就可以直接查看的。所以芝麻凛会给抚子发送这个监控的链接。对于圣地巡礼来说也是十分便利的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/01/09/yurucamera/IMG_9570.webp&#34;
	width=&#34;750&#34;
	height=&#34;423&#34;
	srcset=&#34;https://moriform.github.io/2026/01/09/yurucamera/IMG_9570_hu_633461cdd8193433.webp 480w, https://moriform.github.io/2026/01/09/yurucamera/IMG_9570_hu_ad69ac05e438f256.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;芝麻凛招手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;425px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/01/09/yurucamera/msedge_yQSZOzqzdW.webp&#34;
	width=&#34;889&#34;
	height=&#34;734&#34;
	srcset=&#34;https://moriform.github.io/2026/01/09/yurucamera/msedge_yQSZOzqzdW_hu_7ad8e7c64894db20.webp 480w, https://moriform.github.io/2026/01/09/yurucamera/msedge_yQSZOzqzdW_hu_f08b7b47cf462501.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;霧ヶ峰实景（晚上）&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;290px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;而在第三季中芝麻凛给小明的实时监控来自&lt;a class=&#34;link&#34; href=&#34;http://linearcam.city.fuefuki.yamanashi.jp/index.html?p=2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;花鸟山一本杉公园&lt;/a&gt;，也是可以直连查看的。而且这个监控是直接接收网络信号的，在修改网址后面的数字后刷新页面的话，可以看见是同一个摄像头转向不同角度拍摄的视角，甚至转向时的画面移动也是可以看见的。所以当查看这个监控画面的时候，如果有其他人发送了其他角度的网页请求，当前查看的摄像头就会转向下一个发送的请求的角度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/01/09/yurucamera/IMG_9572.webp&#34;
	width=&#34;750&#34;
	height=&#34;713&#34;
	srcset=&#34;https://moriform.github.io/2026/01/09/yurucamera/IMG_9572_hu_28ed5f6b9f3e6b9.webp 480w, https://moriform.github.io/2026/01/09/yurucamera/IMG_9572_hu_8920f202abd6f48d.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;芝麻凛没招手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;105&#34;
		data-flex-basis=&#34;252px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moriform.github.io/2026/01/09/yurucamera/IMG_9573.webp&#34;
	width=&#34;750&#34;
	height=&#34;347&#34;
	srcset=&#34;https://moriform.github.io/2026/01/09/yurucamera/IMG_9573_hu_f3bb9b501b88684e.webp 480w, https://moriform.github.io/2026/01/09/yurucamera/IMG_9573_hu_93afbd2b03879f9d.webp 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;实景&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;216&#34;
		data-flex-basis=&#34;518px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于新版本Freshrss和Rsshub同时使用时出现的问题</title>
        <link>https://moriform.github.io/2025/10/17/%E5%85%B3%E4%BA%8Efreshrss-1-27%E5%92%8Crsshub%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <pubDate>Fri, 17 Oct 2025 19:40:38 +0000</pubDate>
        
        <guid>https://moriform.github.io/2025/10/17/%E5%85%B3%E4%BA%8Efreshrss-1-27%E5%92%8Crsshub%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述
&lt;/h3&gt;&lt;p&gt;暄穗在使用freshrss在服务器中作为远程rss阅读器的时候最近发现了问题，就是和rsshub同时使用的时候总是会有freshrss“力不从心”的情况：抓取的数量很少，通过管理页面看订阅的feed会红一大片，但是自己手动用浏览器打开rsshub订阅发现是可以打开的。也就是说明明rsshub订阅是没有问题，但是Freshrss就是不抓。如果再看得仔细一点会发现Freshrss确实抓了几个我的rsshub，然后就不抓了，通过Rsshub的日志也能看见Freshrss红的订阅根本没有请求抓取（加把劲啊Freshrss!你为什么不抓！）。&lt;/p&gt;
&lt;h3 id=&#34;原因说明&#34;&gt;原因说明
&lt;/h3&gt;&lt;p&gt;这其实是Fresh 1.27的新特性，如果打开日志可以看见一堆关于红色feed的描述“For that domain, will first retry after”，也就是说Freshrss确实知道他要抓取这个feed，但是他跳过了，说下一次抓取。而下一次他又是同样的说法，于是就永远看不到这个feed的订阅了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;Retry After是1.27的新机制，这个机制可以降低Freshrss的抓取负担。比如说我订阅了一个音乐新闻网站的“信息贴”，“新闻贴”和“求助帖”三个不同的feed，如果Freshrss第一个请求“新闻贴”抓取失败了，那Freshrss就知道这个网站暂时无法登录，相同域名下的“新闻贴”和“求助帖”本次抓取就会跳过，直到下一次再试。&lt;/p&gt;
&lt;p&gt;通过简单举例可以理解这个新机制的好处，但是对于我这样的rsshub用户来说这就是致命打击。首先Rsshub部署基本都是一个域名，其次Rsshub抓取因为自己的配置导致各个网站的成功率不一样。比如说我的Rsshub抓取bilibili的订阅非常流畅，但是抓取weibo经常会失效（原因正在排查）。那么如果我用Freshrss订阅了100个bilibili和一个weibo，Freshrss在抓取完23个bilibili订阅之后灵机一动抓了那个weibo，得到报错之后剩下的77个bilibili也不会抓去了。&lt;/p&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h3&gt;&lt;p&gt;目前在Github已经有人针对相同的问题提出了issue，开发者也将这个提上了日程。而目不知道下一个版本的Freshrss会什么时候公布只能自己想办法了。&lt;/p&gt;
&lt;p&gt;首先是退版本。既然是1.27出了问题那回到上一个版本1.26.3肯定是没有错的。&lt;/p&gt;
&lt;p&gt;其次是使用更稳定的订阅源或取消订阅出问题的订阅源。在我取消了微博的抓取之后我的Freshrss破天荒抓完了所有我在Rsshub的订阅，可喜可贺。而在我更新Weibo的cookie到Rsshub让weibo的抓取成功显示之后也没有红一大片的情况了。&lt;/p&gt;
&lt;p&gt;相关读物：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/FreshRSS/FreshRSS/issues/7880&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[Feature] Improve &amp;ldquo;Retry-After&amp;rdquo; feature to give users more control, especially for RSSHub 改进“Retry-After”功能以给予用户更多控制权，特别是针对RSSHub用户 · Issue #7880 · FreshRSS/FreshRSS&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/FreshRSS/FreshRSS/issues/7870&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[错误] 1.27：503/429 上的域范围“Retry-After”会阻止同一主机上的所有源（RSSHub 用例）。请添加每个 Feed 范围或切换 ·问题 #7870 ·FreshRSS/FreshRSS&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Rsshub在bilibili和weibo的一些基础</title>
        <link>https://moriform.github.io/2025/04/16/rsshub%E5%9C%A8bilibili%E5%92%8Cweibo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Wed, 16 Apr 2025 19:40:38 +0000</pubDate>
        
        <guid>https://moriform.github.io/2025/04/16/rsshub%E5%9C%A8bilibili%E5%92%8Cweibo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h2 id=&#34;这是什么&#34;&gt;这是什么
&lt;/h2&gt;&lt;p&gt;暄穗在实际使用rsshub订阅国内平台的时候遇到了一些网站的反爬虫机制，导致一些网站在直接使用RSShub的时候无法拾取信息。在这个时候需要我们对Rsshub的环境进行一定的配置，比如把自己的账号信息或是浏览器的信息配置在rsshub环境中，程序拾取信息的时候自带正确的head就可以通过反爬取机制的限制。&lt;/p&gt;
&lt;h2 id=&#34;bilibili的cookie配置&#34;&gt;bilibili的cookie配置
&lt;/h2&gt;&lt;p&gt;如在bilibili平台中如果直接裸爬取大概率是会直接报错的，需要将用户的浏览器cookie添加在config文件里面，具体操作如&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_38125348/article/details/141217956&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自建 RSSHub，打造你的专属信息聚合神器！-CSDN博客&lt;/a&gt;中所示。&lt;/p&gt;
&lt;p&gt;简单说，在浏览器登陆了帐号之后，打开网站 &lt;a class=&#34;link&#34; href=&#34;https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/dynamic_new?uid=0&amp;amp;type=8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/dynamic_new?uid=0&amp;amp;type=8&lt;/a&gt; 通过浏览器的开发工具网络模块找到一个cookie值，完全复制下来。&lt;/p&gt;
&lt;p&gt;然后在应用的docker-compose.yml文件中进行文件配置，在rsshub的environment里面加上BILIBILI_COOKIE_你的UID : &amp;ldquo;你的Cookie值&amp;rdquo;，注意cookie值需要用引号括起来，因为我的cookie中有单引号所以我用双引号括起来。差不多长这样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BILIBILI_COOKIE_93428 : &amp;#34;buvid3=B73F8077-A97A-28A2-DF18-DE6B6DE33C7882766infoc; b_nut=1741006682; _uuid=35BEAF7F-FD9E-4624-10CD1-F37D7A465EB383184infoc; enable_web_push=DISABLE; buvid4=1B604924-B54C-8E43-7BF7-89B5E1807EFF83660-025030312-E8iAdFrDoyrfEKkydeDeQw%3D%3D; DedeUserID=3546601188493428; DedeUserIDbili_jct=dbbffc52a0ee7baf9ba16c40b7a06310; sid=8m9rq12i; CURRENT_FNVAL=4048; b_lsid=D46D3B15_1961E5C9EF1; timeMachine=0; bp_t_offset_3546601188493428=1054106693811568640; bsource=search_google&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在完成cookie配置之后重启rsshub就可以爬取rsshub的信息了。&lt;/p&gt;
&lt;h2 id=&#34;weibo的饼干以及防盗链媒体方案&#34;&gt;weibo的饼干以及防盗链媒体方案
&lt;/h2&gt;&lt;p&gt;在使用rsshub订阅微博的时候，有时会遇到“幽灵账号”，就是可以在电脑浏览器上面看到用户的消息，但是在手机端发现他的主页是空白的，而且使用rsshub也不能订阅，这个时候就需要使用weibo的cookie配置，参照rsshub的文档添加环境变量，和bilibili的cookie添加方式大差不差。我没有weibo账号就不演示了。&lt;/p&gt;
&lt;p&gt;另外weibo的防盗链机制使得图片必须通过weibo平台才能够获取，如果直接用rss阅读器没有办法显示图片。需要添加参数通过替换媒体文件的url来使得在rss阅读器中可以显示。&lt;/p&gt;
&lt;p&gt;方法是在rsshub的docker-compose.yml的rsshub的environment中添加参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOTLINK_TEMPLATE: &amp;#39;https://image.baidu.com/search/down?url=$${href_ue}&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOTLINK_INCLUDE_PATHS: /weibo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;后话&#34;&gt;后话
&lt;/h2&gt;&lt;p&gt;由于cookie需要不定期的更新这比较麻烦，所以我尽量避免相关的配置。比如bilibili的话我一般只用电脑看视频，所以它和我的youtube一起放在了电脑本地浏览器的feedbro里面，同时我在电脑端配置了一个rsshub，所以feedbro通过本地rsshub可以直接在浏览器上面对bilibili进行抓取，这样就不用配置cookie了。&lt;/p&gt;
&lt;p&gt;但是偶尔有一次我在检查rss报错的时候发现还是有人使用我的月台信息分发服务，也有学生群体使用我的rsshub来订阅B站上的授课老师来获取知识，所以我现在还是换回了在线的rsshub来订阅bilibili，这样如果cookie需要更新了我及时可以发现。也祝各位同学能够学业有成，取得理想的成绩。&lt;/p&gt;
&lt;p&gt;如果真的有其他平台的cookie配置需求（比如前文说到的微博幽灵账号订阅），可以在这篇文章下方进行评论，不是太复杂的我都可以进行配置。&lt;/p&gt;
&lt;p&gt;最后，我的服务器是阿里云的大陆ecs，想从这里订阅AV和境外新闻是几乎不可能的事情。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
